/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  FileProcessResult,
  FileResult,
  FileTypesResult,
  HTTPValidationError,
} from '../models/index';
import {
    FileProcessResultFromJSON,
    FileProcessResultToJSON,
    FileResultFromJSON,
    FileResultToJSON,
    FileTypesResultFromJSON,
    FileTypesResultToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
} from '../models/index';

export interface DeleteFileRequest {
    fileId: string;
    indexName?: string | null;
}

export interface GetDocumentPdfRequest {
    docId: string;
}

export interface GetDocumentsContentRequest {
    chunkIds: Array<string>;
    indexName?: string | null;
}

export interface GetFilesRequest {
    query: string;
    take: number;
    bucket?: string | null;
    indexName?: string | null;
    files?: string | null;
}

export interface ProcessFileRequest {
    fileName: string;
    fileMimeType: string;
    chunkSize?: number | null;
}

export interface UploadFileRequest {
    fileName: string;
    fileMimeType: string;
    bucket: string;
    id: string;
    indexName?: string | null;
}

/**
 * 
 */
export class FilesApi extends runtime.BaseAPI {

    /**
     * Deletes all chunks belonging to the specified file in the vector store.
     * Delete Files
     */
    async deleteFileRaw(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling deleteFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['indexName'] != null) {
            queryParameters['indexName'] = requestParameters['indexName'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Deletes all chunks belonging to the specified file in the vector store.
     * Delete Files
     */
    async deleteFile(fileId: string, indexName?: string | null, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteFileRaw({ fileId: fileId, indexName: indexName }, initOverrides);
        return await response.value();
    }

    /**
     * Get the document\'s pdf by its ID.
     * Get Document Pdf
     */
    async getDocumentPdfRaw(requestParameters: GetDocumentPdfRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['docId'] == null) {
            throw new runtime.RequiredError(
                'docId',
                'Required parameter "docId" was null or undefined when calling getDocumentPdf().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['docId'] != null) {
            queryParameters['doc_id'] = requestParameters['docId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/documents/pdf`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get the document\'s pdf by its ID.
     * Get Document Pdf
     */
    async getDocumentPdf(docId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getDocumentPdfRaw({ docId: docId }, initOverrides);
        return await response.value();
    }

    /**
     * Get the documents content by their IDs.
     * Get Documents Content
     */
    async getDocumentsContentRaw(requestParameters: GetDocumentsContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string | null>>> {
        if (requestParameters['chunkIds'] == null) {
            throw new runtime.RequiredError(
                'chunkIds',
                'Required parameter "chunkIds" was null or undefined when calling getDocumentsContent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['chunkIds'] != null) {
            queryParameters['chunk_ids'] = requestParameters['chunkIds'];
        }

        if (requestParameters['indexName'] != null) {
            queryParameters['indexName'] = requestParameters['indexName'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/documents/content`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get the documents content by their IDs.
     * Get Documents Content
     */
    async getDocumentsContent(chunkIds: Array<string>, indexName?: string | null, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string | null>> {
        const response = await this.getDocumentsContentRaw({ chunkIds: chunkIds, indexName: indexName }, initOverrides);
        return await response.value();
    }

    /**
     * Get the file types which can be processed.
     * Get File Types
     */
    async getFileTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileTypesResult>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/files/types`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileTypesResultFromJSON(jsonValue));
    }

    /**
     * Get the file types which can be processed.
     * Get File Types
     */
    async getFileTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileTypesResult> {
        const response = await this.getFileTypesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the files matching the query.
     * Get Files
     */
    async getFilesRaw(requestParameters: GetFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileResult>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling getFiles().'
            );
        }

        if (requestParameters['take'] == null) {
            throw new runtime.RequiredError(
                'take',
                'Required parameter "take" was null or undefined when calling getFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['take'] != null) {
            queryParameters['take'] = requestParameters['take'];
        }

        if (requestParameters['bucket'] != null) {
            queryParameters['bucket'] = requestParameters['bucket'];
        }

        if (requestParameters['indexName'] != null) {
            queryParameters['indexName'] = requestParameters['indexName'];
        }

        if (requestParameters['files'] != null) {
            queryParameters['files'] = requestParameters['files'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/files`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileResultFromJSON(jsonValue));
    }

    /**
     * Get the files matching the query.
     * Get Files
     */
    async getFiles(query: string, take: number, bucket?: string | null, indexName?: string | null, files?: string | null, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileResult> {
        const response = await this.getFilesRaw({ query: query, take: take, bucket: bucket, indexName: indexName, files: files }, initOverrides);
        return await response.value();
    }

    /**
     * Processes the file into chunks and directly returns the chunks.  In contrast to the POST /files endpoint, this one does not store the chunks in the vectorstore
     * Post Files Only Processing
     */
    async processFileRaw(requestParameters: ProcessFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileProcessResult>> {
        if (requestParameters['fileName'] == null) {
            throw new runtime.RequiredError(
                'fileName',
                'Required parameter "fileName" was null or undefined when calling processFile().'
            );
        }

        if (requestParameters['fileMimeType'] == null) {
            throw new runtime.RequiredError(
                'fileMimeType',
                'Required parameter "fileMimeType" was null or undefined when calling processFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['fileName'] != null) {
            headerParameters['fileName'] = String(requestParameters['fileName']);
        }

        if (requestParameters['fileMimeType'] != null) {
            headerParameters['fileMimeType'] = String(requestParameters['fileMimeType']);
        }

        if (requestParameters['chunkSize'] != null) {
            headerParameters['chunkSize'] = String(requestParameters['chunkSize']);
        }

        const response = await this.request({
            path: `/files/process`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileProcessResultFromJSON(jsonValue));
    }

    /**
     * Processes the file into chunks and directly returns the chunks.  In contrast to the POST /files endpoint, this one does not store the chunks in the vectorstore
     * Post Files Only Processing
     */
    async processFile(fileName: string, fileMimeType: string, chunkSize?: number | null, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileProcessResult> {
        const response = await this.processFileRaw({ fileName: fileName, fileMimeType: fileMimeType, chunkSize: chunkSize }, initOverrides);
        return await response.value();
    }

    /**
     * Processes the file into chunks and stores them in the vector store.
     * Post Files
     */
    async uploadFileRaw(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['fileName'] == null) {
            throw new runtime.RequiredError(
                'fileName',
                'Required parameter "fileName" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['fileMimeType'] == null) {
            throw new runtime.RequiredError(
                'fileMimeType',
                'Required parameter "fileMimeType" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling uploadFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['fileName'] != null) {
            headerParameters['fileName'] = String(requestParameters['fileName']);
        }

        if (requestParameters['fileMimeType'] != null) {
            headerParameters['fileMimeType'] = String(requestParameters['fileMimeType']);
        }

        if (requestParameters['bucket'] != null) {
            headerParameters['bucket'] = String(requestParameters['bucket']);
        }

        if (requestParameters['id'] != null) {
            headerParameters['id'] = String(requestParameters['id']);
        }

        if (requestParameters['indexName'] != null) {
            headerParameters['indexName'] = String(requestParameters['indexName']);
        }

        const response = await this.request({
            path: `/files`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Processes the file into chunks and stores them in the vector store.
     * Post Files
     */
    async uploadFile(fileName: string, fileMimeType: string, bucket: string, id: string, indexName?: string | null, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.uploadFileRaw({ fileName: fileName, fileMimeType: fileMimeType, bucket: bucket, id: id, indexName: indexName }, initOverrides);
        return await response.value();
    }

}
